#include <proto/dos.h>
#include <proto/exec.h>

#include <string.h>

#include "makefile_writer.h"
#include "function_definition.h"
#include "utils.h"

#define MAKEFILE_CODE_HEADER(lower_case_s) ( \
"# Makefile for project \"" #lower_case_s "\"\n" \
"# Automatically generated by idltool\n" \
"# \n" \
"# $Id$\n" \
"# \n" \
"\n" \
"# Uncomment the next line if you are cross compiling\n" \
"# CROSS_COMPILE = ppc-amigaos-\n" \
"\n" \
"CC     = $(CROSS_COMPILE)gcc \n" \
"CXX    = $(CROSS_COMPILE)c++ \n" \
"AS     = $(CROSS_COMPILE)as \n" \
"LD     = $(CROSS_COMPILE)ld \n" \
"RANLIB = $(CROSS_COMPILE)ranlib \n" \
"RM     = delete\n" \
"# RM     = rm\n" \
"\n" \
"# Change these as required\n" \
"OPTIMIZE = -O3\n" \
"DEBUG    = # -gstabs -DDEBUG\n" \
"CFLAGS   = -Wall $(OPTIMIZE) $(DEBUG)\n" \
"\n" \
"# Flags passed to gcc during linking\n" \
"LINK = \n" \
"\n" \
"# Name of the \"thing\" to build\n" \
"TARGET = " #lower_case_s ".library\n" \
"\n" \
"# Additional linker libraries\n" \
"LIBS = \n" \
"\n" \
"# Version of the library to build\n" \
"VERSION = 53\n" \
"\n" \
)

/*
"# \"" #lower_case_s "\" Interface Source Files\n" \
"" #lower_case_s "_SRCS = " #srcs_list_s " \n" \
"\n" \
*/

#define MAKEFILE_CODE_FOOTER(lower_case_s) ( \
"# -------------------------------------------------------------\n" \
"# Nothing should need changing below this line\n" \
"\n" \
"SRCS = init.c\n" \
"\n" \
"OBJS = $(" #lower_case_s "_SRCS:.c=.o)  $(SRCS:.c=.o)\n" \
"# Rules for building\n" \
"$(TARGET): $(OBJS)\n" \
"	$(CC) $(LINK) -nostartfiles -o $(TARGET) $(OBJS) $(LIBS)\n" \
"\n" \
".PHONY: clean\n" \
"clean:\n" \
"	$(RM) $(TARGET) $(OBJS)\n" \
"\n" \
".PHONY: revision\n" \
"revision:\n" \
"	bumprev $(VERSION) $(TARGET)\n" \
"\n")


BOOL WriteMakefileHeader (BPTR makefile_p, CONST CONST_STRPTR library_s);


BOOL WriteMakefileFooter (BPTR makefile_p, CONST CONST_STRPTR library_s);


BOOL WriteMakefileSources (BPTR makefile_p, CONST CONST_STRPTR library_s, CONST CONST_STRPTR dir_s, struct List * const src_files_p);


BOOL WriteMakefile (CONST CONST_STRPTR  makefile_s, CONST CONST_STRPTR library_s, struct List * const function_defs_p)
{
	BOOL success_flag = FALSE;
	BPTR makefile_p = IDOS->FOpen (makefile_s, MODE_NEWFILE, 0);

	if (makefile_p)
		{
			if (WriteMakefileHeader (makefile_p, library_s))
				{
					CONST_STRPTR src_dir_s = "src";
					
					if (WriteMakefileSources (makefile_p, library_s, src_dir_s, function_defs_p))
						{
							if (WriteMakefileFooter (makefile_p, library_s))
								{
									success_flag = TRUE;
								}
							else
								{
									IDOS->Printf ("Failed to write footer block to makefile \"%s\"\n", makefile_s);
								}

						}
					else
						{
							IDOS->Printf ("Failed to write sources block to makefile \"%s\"\n", makefile_s);
						}

				}
			else
				{
					IDOS->Printf ("Failed to write header block to makefile \"%s\"\n", makefile_s);
				}

			if (IDOS->FClose (makefile_p) == 0)
				{
					IDOS->Printf ("Failed to close makefile \"%s\"\n", makefile_s);
				}
		}
	else
		{
			IDOS->Printf ("Failed to open makefile \"%s\"\n", makefile_s);
		}

	return success_flag;
}


BOOL WriteMakefileHeader (BPTR makefile_p, CONST CONST_STRPTR library_s)
{
	BOOL success_flag = FALSE;
	CONST_STRPTR value_s = MAKEFILE_CODE_HEADER (library_s);
	if (IDOS->FPrintf (makefile_p, "%s", value_s) >= 0)
		{
			success_flag = TRUE;
		}

	return success_flag;
}


BOOL WriteMakefileFooter (BPTR makefile_p, CONST CONST_STRPTR library_s)
{
	BOOL success_flag = FALSE;

	if (IDOS->FPrintf (makefile_p, "%s", MAKEFILE_CODE_FOOTER (library_s)) >= 0)
		{
			success_flag = TRUE;
		}

	return success_flag;
}


BOOL WriteMakefileSources (BPTR makefile_p, CONST CONST_STRPTR library_s, CONST CONST_STRPTR dir_s, struct List * const function_defs_p)
{
	BOOL success_flag = TRUE;
	struct FunctionDefinitionNode *node_p = (struct FunctionDefinitionNode *) IExec->GetHead (function_defs_p);
	CONST_STRPTR current_source_filename_s = "";
	
	while (node_p && success_flag)
		{
			CONST_STRPTR function_source_filename_s = node_p -> fdn_function_def_p -> fd_filename_s;
			
			if (strcmp (current_source_filename_s, function_source_filename_s) != 0)
				{
					STRPTR c_filename_s = GetSourceFilename (function_source_filename_s);
					
					if (c_filename_s)
						{
							STRPTR filename_s = MakeFilename (dir_s, c_filename_s);
		
							if (filename_s)
								{
									if (IDOS->FPrintf (makefile_p, "\t%s \\\n", filename_s) >= 0)
										{
											current_source_filename_s = function_source_filename_s;
										}
									else
										{
											IDOS->Printf ("Failed to write src filename %s to makefile\n", filename_s);
											success_flag = FALSE;
										}
				
									IExec->FreeVec (filename_s);
								}
							else
								{
									IDOS->Printf ("Failed to generate src filename from %s and %s\n", dir_s, function_source_filename_s);
									success_flag = FALSE;
								}
								
							free (c_filename_s);
						}
					else
						{
							IDOS->Printf ("Failed to make src filename from %s\n", function_source_filename_s);
						}

				}
				
			if (success_flag)
				{
					node_p = (struct FunctionDefinitionNode *) IExec->GetSucc (& (node_p -> fdn_node));
				}
		}

	if (success_flag)
		{
			success_flag = (IDOS->FPrintf (makefile_p, "\n") >= 0);
		}

	return success_flag;
}
