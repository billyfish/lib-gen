#include <proto/dos.h>
#include <proto/exec.h>

#include <string.h>
#include <stdlib.h>

#include "makefile_writer.h"
#include "function_definition.h"
#include "utils.h"
#include "debugging_utils.h"


BOOL WriteMakefileHeader (BPTR makefile_p, CONST CONST_STRPTR library_s);


BOOL WriteMakefileFooter (BPTR makefile_p, CONST CONST_STRPTR library_s);


BOOL WriteMakefileSources (BPTR makefile_p, CONST CONST_STRPTR library_s, CONST CONST_STRPTR dir_s, struct List * const src_files_p);


BOOL WriteMakefile (CONST CONST_STRPTR  makefile_s, CONST CONST_STRPTR library_s, struct List * const function_defs_p)
{
	ENTER ();
	BOOL success_flag = FALSE;
	BPTR makefile_p = IDOS->FOpen (makefile_s, MODE_NEWFILE, 0);

	if (makefile_p)
		{
			if (WriteMakefileHeader (makefile_p, library_s))
				{
					STRPTR src_dir_s = ConcatenateStrings (library_s, "_src");

					if (src_dir_s)
						{
							if (WriteMakefileSources (makefile_p, library_s, src_dir_s, function_defs_p))
								{
									if (WriteMakefileFooter (makefile_p, library_s))
										{
											success_flag = TRUE;
										}
									else
										{
											IDOS->Printf ("Failed to write footer block to makefile \"%s\"\n", makefile_s);
										}

								}
							else
								{
									IDOS->Printf ("Failed to write sources block to makefile \"%s\"\n", makefile_s);
								}

							IExec->FreeVec (src_dir_s);
						}
					else
						{
							IDOS->Printf ("Failed to create sources directory name \"%s\"\n", makefile_s);
						}


				}
			else
				{
					IDOS->Printf ("Failed to write header block to makefile \"%s\"\n", makefile_s);
				}

			if (IDOS->FClose (makefile_p) == 0)
				{
					IDOS->Printf ("Failed to close makefile \"%s\"\n", makefile_s);
				}
		}
	else
		{
			IDOS->Printf ("Failed to open makefile \"%s\"\n", makefile_s);
		}

	LEAVE ();
	return success_flag;
}


BOOL WriteMakefileHeader (BPTR makefile_p, CONST CONST_STRPTR library_s)
{
	ENTER ();
	BOOL success_flag = FALSE;
	CONST CONST_STRPTR part0_s =
		"# Automatically generated by idltool\n" \
		"# \n" \
		"# $Id$\n" \
		"# \n" \
		"\n" \
		"# Uncomment the next line if you are cross compiling\n" \
		"# CROSS_COMPILE = ppc-amigaos-\n" \
		"\n" \
		"CC     = $(CROSS_COMPILE)gcc \n" \
		"CXX    = $(CROSS_COMPILE)c++ \n" \
		"AS     = $(CROSS_COMPILE)as \n" \
		"LD     = $(CROSS_COMPILE)ld \n" \
		"RANLIB = $(CROSS_COMPILE)ranlib \n" \
		"RM     = delete\n" \
		"# RM     = rm\n" \
		"\n" \
		"# Change these as required\n" \
		"OPTIMIZE = -O3\n" \
		"DEBUG    = # -gstabs -DDEBUG\n" \
		"CFLAGS   = -Wall $(OPTIMIZE) $(DEBUG)\n" \
		"\n" \
		"# Flags passed to gcc during linking\n" \
		"LINK = \n" \
		"\n" \
		"# Name of the \"thing\" to build\n" \
		"TARGET = ";

	CONST CONST_STRPTR part1_s =
		".library\n" \
		"\n" \
		"# Additional linker libraries\n" \
		"LIBS = \n" \
		"\n" \
		"# Version of the library to build\n" \
		"VERSION = 53\n" \
		"\n";

	if (IDOS->FPrintf (makefile_p, "# Makefile for project %s\n%s%s%s", library_s, part0_s, library_s, part1_s) >= 0)
		{
			success_flag = TRUE;
		}

	LEAVE ();
	return success_flag;
}


BOOL WriteMakefileFooter (BPTR makefile_p, CONST CONST_STRPTR library_s)
{
	ENTER ();
	BOOL success_flag = FALSE;

	CONST CONST_STRPTR part0_s =
		"# -------------------------------------------------------------\n" \
		"# Nothing should need changing below this line\n" \
		"\n" \
		"OBJS = $(";

	CONST_STRPTR part1_s =
		"_SRCS:.c=.o)\n" \
		"# Rules for building\n" \
		"$(TARGET): $(OBJS)\n" \
		"	$(CC) $(LINK) -nostartfiles -o $(TARGET) $(OBJS) $(LIBS)\n" \
		"\n" \
		".PHONY: clean\n" \
		"clean:\n" \
		"	$(RM) $(TARGET) $(OBJS)\n" \
		"\n" \
		".PHONY: revision\n" \
		"revision:\n" \
		"	bumprev $(VERSION) $(TARGET)\n" \
		"\n";

	if (IDOS->FPrintf (makefile_p, "%s%s%s", part0_s, library_s, part1_s) >= 0)
		{
			success_flag = TRUE;
		}

	LEAVE ();
	return success_flag;
}


BOOL WriteMakefileSources (BPTR makefile_p, CONST CONST_STRPTR library_s, CONST CONST_STRPTR dir_s, struct List * const function_defs_p)
{
	ENTER ();

	BOOL success_flag = TRUE;
	struct FunctionDefinitionNode *node_p = (struct FunctionDefinitionNode *) IExec->GetHead (function_defs_p);
	CONST_STRPTR current_source_filename_s = "";

	IDOS->FPrintf (makefile_p, "\nSRCS = init.c \\\n");

	while (node_p && success_flag)
		{
			CONST_STRPTR function_source_filename_s = node_p -> fdn_function_def_p -> fd_filename_s;

			if (strcmp (current_source_filename_s, function_source_filename_s) != 0)
				{
					STRPTR c_filename_s = GetSourceFilename (function_source_filename_s);

					if (c_filename_s)
						{
							STRPTR filename_s = MakeFilename (dir_s, c_filename_s);

							if (filename_s)
								{
									if (IDOS->FPrintf (makefile_p, "\t%s \\\n", filename_s) >= 0)
										{
											current_source_filename_s = function_source_filename_s;
										}
									else
										{
											IDOS->Printf ("Failed to write src filename %s to makefile\n", filename_s);
											success_flag = FALSE;
										}

									IExec->FreeVec (filename_s);
								}
							else
								{
									IDOS->Printf ("Failed to generate src filename from %s and %s\n", dir_s, function_source_filename_s);
									success_flag = FALSE;
								}

							free (c_filename_s);
						}
					else
						{
							IDOS->Printf ("Failed to make src filename from %s\n", function_source_filename_s);
						}

				}

			if (success_flag)
				{
					node_p = (struct FunctionDefinitionNode *) IExec->GetSucc (& (node_p -> fdn_node));
				}
		}

	if (success_flag)
		{
			success_flag = (IDOS->FPrintf (makefile_p, "\n") >= 0);
		}

	LEAVE ();
	return success_flag;
}
