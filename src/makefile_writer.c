#include <proto/dos.h>
#include <proto/exec.h>

#include <string.h>
#include <stdlib.h>

#include "makefile_writer.h"
#include "function_definition.h"
#include "utils.h"
#include "debugging_utils.h"

#include "makefile_utils.h"



STATIC BOOL WriteMakefileSources (BPTR makefile_p, CONST CONST_STRPTR library_s, struct List * const src_files_p);


STATIC BOOL WriteMakefileHeader (BPTR makefile_p, CONST CONST_STRPTR input_dir_s, CONST CONST_STRPTR library_s, CONST CONST_STRPTR output_dir_s);

STATIC BOOL WriteMakefileFooter (BPTR makefile_p, CONST CONST_STRPTR library_s);


BOOL WriteMakefile (CONST CONST_STRPTR  makefile_s, CONST CONST_STRPTR input_dir_s, CONST CONST_STRPTR library_s, struct List * const function_defs_p)
{
	ENTER ();
	BOOL success_flag = FALSE;
	BPTR makefile_p = IDOS->FOpen (makefile_s, MODE_NEWFILE, 0);

	if (makefile_p)
		{
			STRPTR src_dir_s = ConcatenateStrings (library_s, SOURCE_DIR_SUFFIX_S);

			if (src_dir_s)
				{
					if (WriteMakefileHeader (makefile_p, input_dir_s, library_s, src_dir_s))
						{
							if (WriteMakefileSources (makefile_p, library_s, function_defs_p))
								{
									if (WriteMakefileFooter (makefile_p, library_s))
										{
											success_flag = TRUE;
										}
									else
										{
											IDOS->Printf ("Failed to write footer block to makefile \"%s\"\n", makefile_s);
										}

								}
							else
								{
									IDOS->Printf ("Failed to write sources block to makefile \"%s\"\n", makefile_s);
								}
						}
					else
						{
							IDOS->Printf ("Failed to write header block to makefile \"%s\"\n", makefile_s);
						}


					IExec->FreeVec (src_dir_s);
				}
			else
				{
					IDOS->Printf ("Failed to create sources directory name \"%s\"\n", makefile_s);
				}

			if (IDOS->FClose (makefile_p) == 0)
				{
					IDOS->Printf ("Failed to close makefile \"%s\"\n", makefile_s);
				}
		}
	else
		{
			IDOS->Printf ("Failed to open makefile \"%s\"\n", makefile_s);
		}

	LEAVE ();
	return success_flag;
}


static BOOL WriteMakefileHeader (BPTR makefile_p, CONST CONST_STRPTR input_dir_s, CONST CONST_STRPTR library_s, CONST CONST_STRPTR output_dir_s)
{
	ENTER ();
	BOOL success_flag = FALSE;
	
	
	CONST CONST_STRPTR part0_s =
		"# Adapted by libgen and based upon the makefile\n" \
		"# automatically generated by idltool\n" \
		"# \n" \
		"# $Id$\n" \
		"# \n" \
		"\n" \
		"# Uncomment the next line if you are cross compiling\n" \
		"# CROSS_COMPILE = ppc-amigaos-\n" \
		"\n" \
		"CC     = $(CROSS_COMPILE)gcc \n" \
		"CXX    = $(CROSS_COMPILE)c++ \n" \
		"AS     = $(CROSS_COMPILE)as \n" \
		"LD     = $(CROSS_COMPILE)ld \n" \
		"RANLIB = $(CROSS_COMPILE)ranlib \n" \
		"RM     = delete\n" \
		"# RM     = rm\n" \
		"\n" \
		"# Change these as required\n";
		
		
	CONST CONST_STRPTR part1_s = "OPTIMIZE = -O3\n" \
		"DEBUG    = # -gstabs -DDEBUG\n" \
		"CFLAGS   = -Wall $(OPTIMIZE) $(DEBUG) -I$(DIR_AMIGA_LIB_SRC)/include -I$(DIR_AMIGA_LIB_SRC) -I$(DIR_ORIGINAL_LIB_INCLUDES)\n" \
		"\n" \
		"# Flags passed to gcc during linking\n" \
		"LINK = \n" \
		"\n" \
		"# Name of the \"thing\" to build\n" \
		"TARGET = ";

	CONST CONST_STRPTR part2_s =
		".library\n" \
		"\n" \
		"# Additional linker libraries\n" \
		"LIBS = \n" \
		"\n" \
		"# Version of the library to build\n" \
		"VERSION = 53\n" \
		"\n";

	if (IDOS->FPrintf (makefile_p, 
		"# Makefile for project %s\n"
		"%sDIR_AMIGA_LIB_SRC = %s\n"
		"DIR_ORIGINAL_LIB_INCLUDES = .\n"
		"%s%s%s", 
		library_s, part0_s, output_dir_s, part1_s, library_s, part2_s) >= 0)
		{
			success_flag = TRUE;
		}

	LEAVE ();
	return success_flag;
}


static BOOL WriteMakefileFooter (BPTR makefile_p, CONST CONST_STRPTR library_s)
{
	ENTER ();
	BOOL success_flag = FALSE;

	CONST CONST_STRPTR part0_s =
		"# -------------------------------------------------------------\n" \
		"# Nothing should need changing below this line\n" \
		"\n" \
		"OBJS = $(";

	CONST_STRPTR part1_s =
		"_SRCS:.c=.o)\n" \
		"# Rules for building\n" \
		"$(TARGET): $(OBJS)\n" \
		"	$(CC) $(LINK) -nostartfiles -o $(TARGET) $(OBJS) $(LIBS)\n" \
		"\n" \
		".PHONY: clean\n" \
		"clean:\n" \
		"	$(RM) $(TARGET) $(OBJS)\n" \
		"\n" \
		".PHONY: revision\n" \
		"revision:\n" \
		"\tbumprev $(VERSION) $(DIR_SRC)/$(TARGET)\n";		

	if (IDOS->FPrintf (makefile_p, "%s%s%s", part0_s, library_s, part1_s) >= 0)
		{
			success_flag = TRUE;
		}

	LEAVE ();
	return success_flag;
}


BOOL WriteMakefileSources (BPTR makefile_p, CONST CONST_STRPTR library_s, struct List * const function_defs_p)
{
	ENTER ();

	struct FunctionDefinitionNode *node_p = (struct FunctionDefinitionNode *) IExec->GetHead (function_defs_p);
	CONST_STRPTR current_source_filename_s = "";
	BOOL success_flag = (IDOS->FPrintf (makefile_p, 
		"#Add the library initialization code\n$(AMIGA_LIB_SRC) = \\\n\t$(DIR_AMIGA_LIB_SRC)/init.c \\\n\t$(DIR_AMIGA_LIB_SRC)/lib_init.c \\\n\n#Add the source files\n") >= 0);

	while (node_p && success_flag)
		{
			CONST_STRPTR function_source_filename_s = node_p -> fdn_function_def_p -> fd_header_filename_s;

			if (strcmp (current_source_filename_s, function_source_filename_s) != 0)
				{
					STRPTR c_filename_s = GetSourceFilename (library_s, function_source_filename_s, 'c');

					if (c_filename_s)
						{
							
							if (IDOS->FPrintf (makefile_p, "$(AMIGA_LIB_SRC) += %s\n$(ORIGINAL_LIB_SRC) += %s\n\n", c_filename_s, function_source_filename_s) >= 0)
								{
									current_source_filename_s = function_source_filename_s;
								}
							else
								{
									IDOS->Printf ("Failed to write src filename %s to makefile\n", c_filename_s);
									success_flag = FALSE;
								}

							IExec->FreeVec (c_filename_s);
						}
					else
						{
							IDOS->Printf ("Failed to make src filename from %s\n", function_source_filename_s);
						}

				}

			if (success_flag)
				{
					node_p = (struct FunctionDefinitionNode *) IExec->GetSucc (& (node_p -> fdn_node));
				}
		}

	if (success_flag)
		{
			success_flag = (IDOS->FPrintf (makefile_p, "\n\n%s_SRCS = $(DIR_ORIGINAL_LIB_SRC) $(DIR_AMIGA_LIB_SRC)\n\n\n", library_s) >= 0);
		}

	LEAVE ();
	return success_flag;
}
