/*
** This file was generated by LibGen and is based upon the
** output from idltool.
*/

/*
 * :ts=4
 *  $VER: init.c $Revision$ (28-Feb-2015)
 *
 *  Copyright (c) 2015 Hyperion Entertainment CVBA.
 *  All Rights Reserved.
 *
 * $Id$
 *
 * $Log$
 *
 *
 */


#include <exec/exec.h>
#include <proto/exec.h>
#include <dos/dos.h>
#include <stdarg.h>

#define ALLOCATE_LIB_MANAGER_DATA (1)
#include "lib_init.h"

/* Version Tag */
#include "test.library_rev.h"
STATIC CONST UBYTE USED verstag [] = VERSTAG;

/* The Library that we are generating */
struct GeneratedLibrary
{
    struct Library libNode;
    BPTR segList;
    /* If you need more data fields, add them here */
};


/*
 * STATIC PROTOTYPES 
 */

STATIC uint32 _manager_Obtain (struct LibraryManagerInterface *Self);

STATIC uint32 _manager_Release (struct LibraryManagerInterface *Self);

STATIC struct Library *libOpen (struct LibraryManagerInterface *Self, ULONG version);

STATIC APTR libClose (struct LibraryManagerInterface *Self);

STATIC APTR libExpunge (struct LibraryManagerInterface *Self);

STATIC struct Library *libInit (struct Library *LibraryBase, APTR seglist, struct Interface *exec);


/*
 * DEFINITIONS 
 */

/* Open the library */
STATIC struct Library *libOpen (struct LibraryManagerInterface *Self, ULONG version)
{
    struct GeneratedLibrary *libBase = (struct GeneratedLibrary *)Self->Data.LibBase;

    if (version > VERSION)
    {
        return NULL;
    }

    /* Add any specific open code here
       Return 0 before incrementing OpenCnt to fail opening */


    /* Add up the open count */
    libBase->libNode.lib_OpenCnt++;
    return (struct Library *)libBase;

}


/* Close the library */
STATIC APTR libClose (struct LibraryManagerInterface *Self)
{
    struct GeneratedLibrary *libBase = (struct GeneratedLibrary *) Self->Data.LibBase;
    /* Make sure to undo what open did */


    /* Make the close count */
    ((struct Library *)libBase)->lib_OpenCnt--;

    return 0;
}


/* Expunge the library */
STATIC APTR libExpunge (struct LibraryManagerInterface *Self)
{
    /* If your library cannot be expunged, return 0 */
    struct ExecIFace *IExec
        = (struct ExecIFace *)(*(struct ExecBase **)4)->MainInterface;
    APTR result = (APTR)0;
    struct Library *libBase = (struct Library *)Self->Data.LibBase;
    if (libBase->libNode.lib_OpenCnt == 0)
    {
	     result = (APTR)libBase->segList;
        /* Undo what the init code did */

        IExec->Remove((struct Node *)libBase);
        IExec->DeleteLibrary((struct Library *)libBase);
    }
    else
    {
        result = (APTR)0;
        libBase->libNode.lib_Flags |= LIBF_DELEXP;
    }
    return result;
}


/* The ROMTAG Init Function */
STATIC struct Library *libInit(struct Library *LibraryBase, APTR seglist, struct Interface *exec)
{
    struct GeneratedLibrary *libBase = (struct GeneratedLibrary *) LibraryBase;
    struct ExecIFace *IExec UNUSED = (struct ExecIFace *) exec;

    libBase->libNode.lib_Node.ln_Type = NT_LIBRARY;
    libBase->libNode.lib_Node.ln_Pri  = 0;
    libBase->libNode.lib_Node.ln_Name = "";
    libBase->libNode.lib_Flags        = LIBF_SUMUSED|LIBF_CHANGED;
    libBase->libNode.lib_Version      = VERSION;
    libBase->libNode.lib_Revision     = REVISION;
    libBase->libNode.lib_IdString     = VSTRING;

    libBase->segList = (BPTR)seglist;

    /* Add additional init code here if you need it. For example, to open additional
       Libraries:
       libBase->UtilityBase = IExec->OpenLibrary("utility.library", 50L);
       if (libBase->UtilityBase)
       {
           libBase->IUtility = (struct UtilityIFace *) IExec->GetInterface(ElfBase->UtilityBase,
              "main", 1, NULL);
           if (!libBase->IUtility)
               return NULL;
       } else return NULL; */

       return (struct Library *) libBase;
}


/* ------------------- Manager Interface ------------------------ */
/* These are generic. Replace if you need more fancy stuff */
STATIC uint32 _manager_Obtain (struct LibraryManagerInterface *Self)
{
	uint32 res;
	__asm__ __volatile__(
	"1:	lwarx	%0,0,%1\n"
	"addic	%0,%0,1\n"
	"stwcx.	%0,0,%1\n"
	"bne-	1b"
	: "=&r" (res)
	: "r" (&Self->Data.RefCount)
	: "cc", "memory");

	return res;
}


STATIC uint32 _manager_Release (struct LibraryManagerInterface *Self)
{
	uint32 res;
	__asm__ __volatile__(
	"1:	lwarx	%0,0,%1\n"
	"addic	%0,%0,-1\n"
	"stwcx.	%0,0,%1\n"
	"bne-	1b"
	: "=&r" (res)
	: "r" (&Self->Data.RefCount)
	: "cc", "memory");

	return res;
}


/* Manager interface vectors */
CONST APTR lib_manager_vectors [] =
{
	_manager_Obtain,
	_manager_Release,
	NULL,
	NULL,
	libOpen,
	libClose,
	libExpunge,
	NULL,
	(APTR) -1
};


/* "__library" interface tag list */
CONST struct TagItem lib_managerTags [] =
{
	{ MIT_Name, (Tag) "__library" },
	{ MIT_VectorTable, (Tag) lib_manager_vectors},
	{ MIT_Version,	1 },
	{ TAG_DONE, 0 }
};
